#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;


class GraphAndPairs
{
public:
    int node = -1;
    vector <int> construct(int d, int k)
    {
        if(d == 2)
        {
            vector<int> ans;
            while(k>0)
            {
                int now = 0, cnt = 0;
                int one = ++node;
                while(cnt+now <= k)
                {
                    ans.push_back(one);
                    node++;
                    ans.push_back(node);
                    cnt += now;
                    now++;
                }
                k -= cnt;
            }
            vector<int> res;
            res.push_back(node+1);
            for(int i = 0; i < ans.size(); i++)
                res.push_back(ans[i]);
            return res;
        }
        vector<int> res;
        while(k>0)
        {
            int x = sqrt(k);
            vector<int> tem = func(d,x);
            for(int i = 0; i < tem.size(); i++)
                res.push_back(tem[i]);
            k -= x*x;
        }
        vector<int> ans;
        ans.push_back(node+1);
        for(int i = 0; i < res.size(); i++)
            ans.push_back(res[i]);
        return ans;

    }

    vector<int> func(int d, int n)
    {
        vector<int> ans;
        node++;
        int one = node;
        for(int i = 0; i < d-2; i++)
        {
            ans.push_back(node);
            node++;
            ans.push_back(node);
        }
        int two = node;
        for(int i = 0; i < n; i++)
        {
            ans.push_back(one);
            node++;
            ans.push_back(node);
            ans.push_back(two);
            node++;
            ans.push_back(node);
        }
        return ans;
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, bool hasAnswer, vector <int> p2)
{
    cout << "Test " << testNum << ": [" << p0 << "," << p1;
    cout << "]" << endl;
    GraphAndPairs *obj;
    vector <int> answer;
    obj = new GraphAndPairs();
    clock_t startTime = clock();
    answer = obj->construct(p0, p1);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << "{";
        for (int i = 0; int(p2.size()) > i; ++i)
        {
            if (i > 0)
            {
                cout << ",";
            }
            cout << p2[i];
        }
        cout << "}" << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << "{";
    for (int i = 0; int(answer.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << answer[i];
    }
    cout << "}" << endl;
    if (hasAnswer)
    {
        if (answer.size() != p2.size())
        {
            res = false;
        }
        else
        {
            for (int i = 0; int(answer.size()) > i; ++i)
            {
                if (answer[i] != p2[i])
                {
                    res = false;
                }
            }
        }
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    all_right = true;

    int p0;
    int p1;
    vector <int> p2;

    {
        // ----- test 0 -----
        p0 = 2;
        p1 = 1;
        int t2[] = {4,0,1,1,3,3,2,2,0,1,2};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
        // ------------------
    }

    {
        // ----- test 1 -----
        p0 = 2;
        p1 = 2;
        int t2[] = {8,0,1,1,3,3,2,2,0,1,2,4,5,5,7,7,6,6,4,5,6};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
        // ------------------
    }

    {
        // ----- test 2 -----
        p0 = 4;
        p1 = 4;
        int t2[] = {8,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,0};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
        // ------------------
    }

    {
        // ----- test 3 -----
        p0 = 5;
        p1 = 2;
        int t2[] = {10,0,1,1,2,2,3,3,4,5,6,6,7,7,8,8,9,0,5,1,6,2,7,3,8,4,9};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
        // ------------------
    }

    if (all_right)
    {
        cout << "You're a stud (at least on the example cases)!" << endl;
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
